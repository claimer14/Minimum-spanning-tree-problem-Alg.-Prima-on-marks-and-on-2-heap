Принцип алгоритма Прима основан на "жадной" стратегии построения минимального остовного дерева. Вот основная идея:

1. Начальная подготовка:
   * Берем произвольную начальную вершину (обычно 0)
   * Создаем пустую бинарную кучу
   * Создаем массив для отметки посещенных вершин
   * Создаем пустой список для хранения рёбер MST
2. Инициализация:
   * Помечаем начальную вершину как посещенную
   * Добавляем в кучу все рёбра, исходящие из начальной вершины
   * В куче каждое ребро хранится как кортеж (вес, откуда, куда)
3. Основной цикл:
   * Извлекаем из кучи ребро с минимальным весом
   * Если конечная вершина ребра уже посещена, пропускаем его
   * Иначе:
      * Добавляем ребро в MST
      * Помечаем новую вершину как посещенную
      * Добавляем в кучу все рёбра из новой вершины
      * Повторяем, пока не получим n-1 рёбер (где n - число вершин)
4. Особенности работы с кучей:
   * Куча автоматически поддерживает элементы в отсортированном виде
   * Извлечение минимума (heappop) занимает O(log n)
   * Добавление элемента (heappush) занимает O(log n)

Граф:
   1
 2/ \4
 A--B
 3\ /5
   C

1. Начинаем с A:
   Куча: [(2,A,B), (3,A,C)]

2. Извлекаем (2,A,B):
   MST: A-B
   Куча: [(3,A,C), (4,B,C)]

3. Извлекаем (3,A,C):
   MST: A-B, A-C
   Готово!


Сложность алгоритма: O(E log V), где:

- E - количество рёбер

- V - количество вершин

- log V - сложность операций с кучей

Каждая операция с кучей требует O(log V)
Всего обрабатывается E ребер
Итого: O(E) O(log V) = O(E log V)