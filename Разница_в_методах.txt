Алгоритм Прима на метках:

1. На каждом шаге просматривает все вершины для поиска минимального ребра
2. Хранит метки и расстояния для каждой вершины
3. Сложность O(V²) из-за:
    V-1 шагов добавления вершин
На каждом шаге просмотр V вершин

4. Пример работы:

    # На каждом шаге:
    possible_nodes = np.where(labels == 0)[0]  # все непосещенные вершины
    node_to_add = possible_nodes[dists[possible_nodes].argmin()]  # ищем минимум среди всех


Алгоритм Прима на куче:
    1. Хранит только "активные" ребра в куче
    2. Автоматически получает минимальное ребро из кучи
    3. Сложность O(E log V) из-за:
        log V на операции с кучей
        E операций добавления/извлечения
Пример работы:
    # На каждом шаге:
    weight, u, v = heappop(heap)  # сразу получаем минимальное ребро
    # Добавляем только нужные ребра
    for neighbor in vertex_neighbors[v]:
        if not visited[neighbor]:
            heappush(heap, (weight, v, neighbor))


Почему куча работает быстрее:
    1.Не просматривает все вершины каждый раз
    2.Хранит только нужные ребра
    3.Быстро (за log V) получает минимум
    4.Меньше лишних операций

Пример на маленьком графе:
    2
 A----B
 |   / |
  3  |5
 | /   |
 C-----D
    6

Метки: каждый раз просматривает все вершины
Куча: сразу извлекает минимальное ребро (2) и работает только с соседями
Поэтому на больших графах разница становится очень существенной.